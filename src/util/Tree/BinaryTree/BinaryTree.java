package util.Tree.BinaryTree;import util.Queue.LinkedQueue;import util.Stack.LinkedStack;/** * Created by yejiaquan on 2016/10/19. */public class BinaryTree<T extends Comparable<? super T>>{    public BinaryNode<T> root;    private BinaryNode<T>p;    public BinaryTree(){        this.root=null;    }    public BinaryTree(BinaryNode root){        this.root=root;        p=this.root;    }    public BinaryTree(T[]prelist){        this.root=create(prelist);        p=this.root;    }    private int i=0;    private BinaryNode<T>create(T[]prelist){        BinaryNode<T>p=null;        if (i<prelist.length){            T elem=prelist[i];            i++;            System.out.println(i);            if (elem!=null){                p=new BinaryNode<T>(elem);                p.left=create(prelist);                p.right=create(prelist);            }        }        return p;    }    public boolean isEmpty(){        return this.root==null;    }    public String toString (){        return toString(this.root);    }    public String toString (BinaryNode<T>p){        if (p==null)            return "^";        return p.data.toString()+""+toString(p.left)+toString(p.right);    }    public int size() {        int size=1;        LinkedQueue<BinaryNode<T>>que=new LinkedQueue<BinaryNode<T>>();        BinaryNode<T>p=this.root;        while (p!=null){            if (p.left!=null) {                que.add(p.left);                size++;            }            if (p.right!=null) {                que.add(p.right);                size++;            }            p=que.poll();        }        return size;    }//    public int height() {//    }    public void preorder() {        preorder(this.root);        System.out.println();    }    public void preorder(BinaryNode<T>p) {        if(p!=null){            System.out.print(p.data.toString()+"");            preorder(p.left);            preorder(p.right);        }    }    public void inorder() {        inorder(this.root);        System.out.println();    }    public void inorder(BinaryNode<T>p) {        if(p!=null){            inorder(p.left);            System.out.print(p.data.toString()+"");            inorder(p.right);        }    }    public void postorder() {        postorder(this.root);        System.out.println();    }    public void postorder(BinaryNode<T>p) {        if (p!=null){            postorder(p.left);            postorder(p.right);            System.out.print(p.data.toString()+"");        }    }    public void levelorder() {        System.out.print("层次遍历：");        LinkedQueue<BinaryNode<T>>que=new LinkedQueue<BinaryNode<T>>();        BinaryNode<T>p=this.root;        while (p!=null){            System.out.print(p.data + "");            if (p.left!=null)                que.add(p.left);            if (p.right!=null)                que.add(p.right);            p=que.poll();        }        System.out.println();    }    public BinaryNode<T> insert(T x){        return this.root=new BinaryNode<T>(x,this.root,null);    }    public BinaryNode<T> insert(BinaryNode<T> parent, T x, boolean leftChild){        if(x==null)            return null;        if (leftChild)            return parent.left=new BinaryNode<T>(x,parent.left,null);        return parent.right=new BinaryNode<T>( x,null,parent.right);    }    public void remove(BinaryNode<T> parent,boolean leftChild){        if (leftChild)            parent.left=null;        else parent.right=null;    }    public void printGenList(){        System.out.print("二叉树的广义表表示：");        printGenList(this.root);        System.out.println();    }    public void printGenList(BinaryNode<T>p){        if (p==null){            System.out.print("^");        }else{            System.out.print(p.data.toString()+"");            if (p.left!=null||p.right!=null){                System.out.print("(");                printGenList(p.left);                System.out.print(",");                printGenList(p.right);                System.out.print(")");            }        }    }    public void preorderTraverse(){        System.out.print("先跟次序遍历（非递归）：");        LinkedStack<BinaryNode<T>>stack=new LinkedStack<BinaryNode<T>>();        BinaryNode<T>p=this.root;        while (p!=null||!stack.isEmpty()){            if (p!=null){                System.out.print(p.data+"");                stack.push(p);                p=p.left;            }else {                System.out.print("^");                p=stack.pop();                p=p.right;            }        }        System.out.println();    }    public void clear() {        this.root=null;    }    public BinaryNode<T> search(T key) {        LinkedStack<BinaryNode<T>>stack=new LinkedStack<BinaryNode<T>>();        BinaryNode<T>p=this.root;        while (p!=null||!stack.isEmpty()){            if (p!=null){                if (p.data.compareTo(key)==0)                    return p;                stack.push(p);                p=p.left;            }else {                p=stack.pop();                p=p.right;            }        }        return p;    }    public int levelNum(){        LinkedStack<BinaryNode<T>>stack=new LinkedStack<BinaryNode<T>>();        BinaryNode<T>p=this.root;        int num=0;        while (p!=null||!stack.isEmpty()){            if (p!=null){                if (p.isLeaf())                    num++;                stack.push(p);                p=p.left;            }else {                p=stack.pop();                p=p.right;            }        }        return num;    }//    public boolean contain(T key) {//        return false;//    }//    public int level(T key) {//        return 0;//    }}